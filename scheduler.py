import json
import logging
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional

from iris_client import IrisClient

ISOWEEKDAYS = {
    "monday": 1,
    "tuesday": 2,
    "wednesday": 3,
    "thursday": 4,
    "friday": 5,
    "saturday": 6,
    "sunday": 7,
}


def creation_time(measurement: dict) -> datetime:
    return datetime.fromisoformat(measurement["creation_time"])


def start_time(measurement: dict) -> datetime:
    return datetime.fromisoformat(measurement["start_time"])


def end_time(measurement: dict) -> datetime:
    return datetime.fromisoformat(measurement["end_time"])


def duration(measurement: dict) -> Optional[timedelta]:
    if measurement.get("start_time") and measurement.get("end_time"):
        return end_time(measurement) - start_time(measurement)
    return None


def measurement_name(measurement: dict) -> str:
    name = "Unknown"
    for tag in measurement["tags"]:
        if tag.endswith(".json"):
            name = tag
            break
    return name


def generate_md(measurements):
    template = "{:<24} | {:<10} | {:<16} | {:<20} | {:<20} | {:<20} | {:<20} | {:<20}\n"
    md = "# Measurements\n"
    md += "_Generated by scheduler.py._\n\n"
    md += template.format(
        "Name", "UUID", "Tool", "State", "Created", "Start", "End", "Duration"
    )
    md += template.format("--", "--", "--", "--", "--", "--", "--", "--")
    measurements = sorted(
        measurements, key=lambda x: (measurement_name(x), creation_time(x))
    )
    for measurement in measurements:
        md += template.format(
            measurement_name(measurement),
            measurement["uuid"].split("-")[0],
            str(measurement.get("tool")),
            str(measurement.get("state")),
            str(measurement.get("creation_time")),
            str(measurement.get("start_time")),
            str(measurement.get("end_time")),
            str(duration(measurement)),
        )
    return md


def should_schedule(freq, last_measurement, meta):
    diff = None
    if last_measurement:
        diff = datetime.now() - start_time(last_measurement)
    if freq == "hourly":
        if not last_measurement or diff >= timedelta(hours=1):
            return True
    if freq == "daily":
        if not last_measurement or diff >= timedelta(days=1):
            return True
    if freq == "weekly":
        if datetime.now().isoweekday() == ISOWEEKDAYS[meta]:
            if not last_measurement or diff > timedelta(days=1):
                return True
    return False


def schedule_measurements(client: IrisClient) -> None:
    for freq in ("oneshot", "hourly", "daily", "weekly"):
        for file in Path(f"_{freq}").glob("*.json"):
            logging.info("Processing %s...", file)

            # Extract the optional meta component:
            # measurement.saturday.json => saturday
            meta = ""
            if len(str(file).split(".")) == 3:
                meta = str(file).split(".")[1].lower().strip()

            measurement = json.loads(file.read_text())
            measurement.setdefault("tags", [])
            measurement["tags"].append(file.name)
            measurement["tags"].append("scheduled")

            measurements = client.all("/measurements/", params=dict(tag=file.name))
            if measurements:
                last = sorted(measurements, key=creation_time)[-1]
            else:
                last = None

            if should_schedule(freq, last, meta):
                logging.info("Scheduling measurement...")
                client.post("/measurements/", json=measurement)
            else:
                logging.info("Skipping measurement...")


def upload_target_lists(client: IrisClient) -> None:
    for file in Path("targets").glob("*.csv"):
        logging.info("Uploading %s...", file)
        with file.open("rb") as f:
            client.post("/targets/", files=dict(target_file=f))


def index_measurements(client: IrisClient, destination: Path) -> None:
    measurements = client.all("/measurements/", params=dict(tag="scheduled"))
    destination.write_text(generate_md(measurements))


def main():
    logging.basicConfig(level=logging.INFO)
    with IrisClient() as client:
        upload_target_lists(client)
        schedule_measurements(client)
        index_measurements(client, Path("MEASUREMENTS.md"))


if __name__ == "__main__":
    main()
