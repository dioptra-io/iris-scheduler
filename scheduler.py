import json
import logging
import os
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional

import requests

IRIS_URL = "https://iris.dioptra.io/api"

ISOWEEKDAYS = {
    "monday": 1,
    "tuesday": 2,
    "wednesday": 3,
    "thursday": 4,
    "friday": 5,
    "saturday": 6,
    "sunday": 7,
}


def request(method, path, **kwargs):
    req = requests.request(method, IRIS_URL + path, timeout=5, **kwargs)
    try:
        req.raise_for_status()
    except requests.HTTPError as e:
        logging.error(req.text)
        raise e
    return req.json()


def start_time(measurement: dict) -> datetime:
    return datetime.fromisoformat(measurement["start_time"])


def end_time(measurement: dict) -> datetime:
    return datetime.fromisoformat(measurement["end_time"])


def duration(measurement: dict) -> Optional[timedelta]:
    if measurement.get("start_time") and measurement.get("end_time"):
        return end_time(measurement) - start_time(measurement)
    return None


def measurement_name(measurement: dict) -> str:
    name = "Unknown"
    for tag in measurement["tags"]:
        if tag.endswith(".json"):
            name = tag
            break
    return name


def generate_md(measurements):
    template = "{:<24} | {:<10} | {:<16} | {:<20} | {:<20} | {:<20}\n"
    md = "# Measurements\n"
    md += "_Generated by scheduler.py._\n\n"
    md += template.format("Name", "UUID", "Tool", "Start", "End", "Duration")
    md += template.format("--", "--", "--", "--", "--", "--")
    measurements = sorted(
        measurements, key=lambda x: (measurement_name(x), start_time(x))
    )
    for measurement in measurements:
        md += template.format(
            measurement_name(measurement),
            measurement["uuid"].split("-")[0],
            measurement.get("tool"),
            measurement.get("start_time"),
            measurement.get("end_time"),
            str(duration(measurement)),
        )
    return md


def should_schedule(freq, last_measurement, meta):
    diff = None
    if last_measurement:
        diff = datetime.now() - start_time(last_measurement)
    if freq == "hourly":
        if not last_measurement or diff >= timedelta(hours=1):
            return True
    if freq == "daily":
        if not last_measurement or diff >= timedelta(days=1):
            return True
    if freq == "weekly":
        if datetime.now().isoweekday() == ISOWEEKDAYS[meta]:
            if not last_measurement or diff > timedelta(days=1):
                return True
    return False


def authenticate(username: str, password: str) -> dict:
    logging.info("Authenticating...")
    data = {"username": username, "password": password}
    res = request("POST", "/profile/token", data=data)
    return {"Authorization": f"Bearer {res['access_token']}"}


def schedule_measurements(headers: dict) -> None:
    for freq in ("oneshot", "hourly", "daily", "weekly"):
        for file in Path(f"_{freq}").glob("*.json"):
            logging.info(f"Processing {file}...")

            # Extract the optional meta component:
            # measurement.saturday.json => saturday
            meta = ""
            if len(str(file).split(".")) == 3:
                meta = str(file).split(".")[1].lower().strip()

            measurement = json.loads(file.read_text())
            measurement.setdefault("tags", [])
            measurement["tags"].append(file.name)
            measurement["tags"].append("scheduled")

            res = request(
                "GET",
                "/measurements/",
                params={"limit": 200, "tag": file.name},
                headers=headers,
            )

            last = None
            if res["count"] > 0:
                last = sorted(res["results"], key=start_time)[-1]
            if should_schedule(freq, last, meta):
                logging.info("Scheduling measurement...")
                request("POST", "/measurements/", json=measurement, headers=headers)
            else:
                logging.info("Skipping measurement...")


def upload_target_lists(headers: dict) -> None:
    for file in Path("targets").glob("*.csv"):
        logging.info(f"Uploading {file}...")
        with file.open("rb") as f:
            request("POST", "/targets/", files={"target_file": f}, headers=headers)


def main():
    logging.basicConfig(level=logging.INFO)
    headers = authenticate(os.environ["IRIS_USERNAME"], os.environ["IRIS_PASSWORD"])
    upload_target_lists(headers)
    schedule_measurements(headers)
    res = request(
        "GET",
        "/measurements/",
        params={"limit": 200, "tag": "scheduled"},
        headers=headers,
    )
    Path("MEASUREMENTS.md").write_text(generate_md(res["results"]))


if __name__ == "__main__":
    main()
