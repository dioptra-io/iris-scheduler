import json
import logging
import os
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional

from oauthlib.oauth2 import LegacyApplicationClient
from requests import HTTPError, Session
from requests_oauthlib import OAuth2Session

IRIS_URL = "https://api.iris.dioptra.io"

ISOWEEKDAYS = {
    "monday": 1,
    "tuesday": 2,
    "wednesday": 3,
    "thursday": 4,
    "friday": 5,
    "saturday": 6,
    "sunday": 7,
}


def request(session, method, path, **kwargs):
    req = session.request(method, IRIS_URL + path, timeout=5, **kwargs)
    try:
        req.raise_for_status()
    except HTTPError as e:
        logging.error(req.text)
        raise e
    return req.json()


def start_time(measurement: dict) -> datetime:
    return datetime.fromisoformat(measurement["start_time"])


def end_time(measurement: dict) -> datetime:
    d = datetime.fromisoformat(measurement["end_time"])
    # https://github.com/dioptra-io/iris/commit/a60551b6e5405396a935bbf1ff69ac6cf3082da1
    if d < datetime(2021, 10, 26):
        d -= timedelta(hours=2)
    return d


def duration(measurement: dict) -> Optional[timedelta]:
    if measurement.get("start_time") and measurement.get("end_time"):
        return end_time(measurement) - start_time(measurement)
    return None


def measurement_name(measurement: dict) -> str:
    name = "Unknown"
    for tag in measurement["tags"]:
        if tag.endswith(".json"):
            name = tag
            break
    return name


def generate_md(measurements):
    template = "{:<24} | {:<10} | {:<16} | {:<20} | {:<20} | {:<20}\n"
    md = "# Measurements\n"
    md += "_Generated by scheduler.py._\n\n"
    md += template.format("Name", "UUID", "Tool", "Start", "End", "Duration")
    md += template.format("--", "--", "--", "--", "--", "--")
    measurements = sorted(
        measurements, key=lambda x: (measurement_name(x), start_time(x))
    )
    for measurement in measurements:
        md += template.format(
            measurement_name(measurement),
            measurement["uuid"].split("-")[0],
            str(measurement.get("tool")),
            str(measurement.get("start_time")),
            str(measurement.get("end_time")),
            str(duration(measurement)),
        )
    return md


def should_schedule(freq, last_measurement, meta):
    diff = None
    if last_measurement:
        diff = datetime.now() - start_time(last_measurement)
    if freq == "hourly":
        if not last_measurement or diff >= timedelta(hours=1):
            return True
    if freq == "daily":
        if not last_measurement or diff >= timedelta(days=1):
            return True
    if freq == "weekly":
        if datetime.now().isoweekday() == ISOWEEKDAYS[meta]:
            if not last_measurement or diff > timedelta(days=1):
                return True
    return False


def schedule_measurements(session: Session) -> None:
    for freq in ("oneshot", "hourly", "daily", "weekly"):
        for file in Path(f"_{freq}").glob("*.json"):
            logging.info(f"Processing {file}...")

            # Extract the optional meta component:
            # measurement.saturday.json => saturday
            meta = ""
            if len(str(file).split(".")) == 3:
                meta = str(file).split(".")[1].lower().strip()

            measurement = json.loads(file.read_text())
            measurement.setdefault("tags", [])
            measurement["tags"].append(file.name)
            measurement["tags"].append("scheduled")

            res = request(
                session,
                "GET",
                "/measurements/",
                params={"limit": 200, "tag": file.name},
            )

            last = None
            if res["count"] > 0:
                last = sorted(res["results"], key=start_time)[-1]
            if should_schedule(freq, last, meta):
                logging.info("Scheduling measurement...")
                request(session, "POST", "/measurements/", json=measurement)
            else:
                logging.info("Skipping measurement...")


def upload_target_lists(session: Session) -> None:
    for file in Path("targets").glob("*.csv"):
        logging.info(f"Uploading {file}...")
        with file.open("rb") as f:
            request(session, "POST", "/targets/", files={"target_file": f})


def main():
    logging.basicConfig(level=logging.INFO)
    session = OAuth2Session(client=LegacyApplicationClient(client_id="iris-scheduler"))
    session.fetch_token(
        f"{IRIS_URL}/profile/token",
        username=os.environ["IRIS_USERNAME"],
        password=os.environ["IRIS_PASSWORD"],
    )
    upload_target_lists(session)
    schedule_measurements(session)
    res = request(
        session,
        "GET",
        "/measurements/",
        params={"limit": 200, "tag": "scheduled"},
    )
    Path("MEASUREMENTS.md").write_text(generate_md(res["results"]))


if __name__ == "__main__":
    main()
