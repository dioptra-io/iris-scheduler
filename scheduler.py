import json
import logging
import os
from datetime import datetime, timedelta
from pathlib import Path

import requests

IRIS_URL = "https://iris.dioptra.io/api"

ISOWEEKDAYS = {
    "monday": 1,
    "tuesday": 2,
    "wednesday": 3,
    "thursday": 4,
    "friday": 5,
    "saturday": 6,
    "sunday": 7,
}


def request(method, path, **kwargs):
    req = requests.request(method, IRIS_URL + path, timeout=5, **kwargs)
    try:
        req.raise_for_status()
    except requests.HTTPError as e:
        logging.error(req.text)
        raise e
    return req.json()


def start_time(measurement):
    return datetime.fromisoformat(measurement["start_time"])


def end_time(measurement):
    return datetime.fromisoformat(measurement["end_time"])


def should_schedule(freq, last_measurement, meta):
    diff = None
    if last_measurement:
        diff = datetime.now() - start_time(last_measurement)
    if freq == "hourly":
        if not last_measurement or diff >= timedelta(hours=1):
            return True
    if freq == "daily":
        if not last_measurement or diff >= timedelta(days=1):
            return True
    if freq == "weekly":
        # Schedule on saturday by default.
        day = ISOWEEKDAYS.get(meta, 6)
        if datetime.now().isoweekday() == day:
            if not last_measurement or diff >= timedelta(weeks=1):
                return True
    return False


def generate_md(index):
    md = "# Measurements"
    md += "\n_Generated by scheduler.py._"

    for freq in index:
        md += f"\n\n# {freq}"
        md += "\nFile | UUID | Tool | Start | End | Duration"
        md += "\n-----|------|------|-------|-----|---------"
        for file, measurements in index[freq].items():
            measurements.sort(key=start_time, reverse=True)
            for measurement in measurements:
                uuid = measurement["uuid"]
                md += f"\n[{file.name}]({file})"
                md += f"| [{uuid[:8]}]({IRIS_URL}/measurements/{uuid})"
                md += f"| {measurement.get('tool')}"
                md += f"| {measurement.get('start_time')}"
                md += f"| {measurement.get('end_time')}"
                duration = None
                if measurement.get("start_time") and measurement.get("end_time"):
                    duration = end_time(measurement) - start_time(measurement)
                md += f"| {duration}"
    md += "\n"
    return md


def main():
    logging.basicConfig(level=logging.INFO)

    logging.info("Authenticating...")
    data = {
        "username": os.environ["IRIS_USERNAME"],
        "password": os.environ["IRIS_PASSWORD"],
    }
    res = request("POST", "/profile/token", data=data)
    headers = {"Authorization": f"Bearer {res['access_token']}"}

    logging.info("Uploading target lists...")
    for file in Path("targets").glob("*.csv"):
        logging.info(f"Processing {file}...")
        with file.open("rb") as f:
            request("POST", "/targets/", files={"target_file": f}, headers=headers)

    # Index used to generate the MEASUREMENTS.md file.
    index = {}

    for freq in ("oneshot", "hourly", "daily", "weekly")[::-1]:
        for file in Path(freq).glob("*.json"):
            logging.info(f"Processing {file}...")

            # Extract the optional meta component:
            # measurement.saturday.json => saturday
            meta = ""
            if len(str(file).split(".")) == 3:
                meta = str(file).split(".")[1].lower().strip()

            measurement = json.loads(file.read_text())
            measurement.setdefault("tags", [])
            measurement["tags"].append(file.name)
            measurement["tags"].append("scheduled")

            res = request(
                "GET",
                "/measurements/",
                params={"limit": 200, "tag": file.name},
                headers=headers,
            )

            last = None
            index.setdefault(freq, {})
            index[freq][file] = []

            if res["count"] > 0:
                last = sorted(res["results"], key=start_time)[-1]
                index[freq][file].extend(res["results"])
            if should_schedule(freq, last, meta):
                logging.info("Scheduling measurement...")
                res = request(
                    "POST", "/measurements/", json=measurement, headers=headers
                )
                index[freq][file].append(
                    {"start_time": datetime.now().isoformat(), **res}
                )
            else:
                logging.info("Measurement already scheduled")

    md = generate_md(index)
    Path("MEASUREMENTS.md").write_text(md)


if __name__ == "__main__":
    main()
